<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - interactive cubes</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			body {
				background-color: #f0f0f0;
				color: #444;
			}
			a {
				color: #08f;
			}
			.ui {
			position: absolute;
			}

			button{
			margin: 20px;
			}
		</style>
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - scatterplot
		</div>
<!-- 		<button style="top:0" id="fire" class="ui">Fire</button>
		<button style="bottom:0" id="spell" class="ui">Spell</button>
		<button style="right:0" id="health" class="ui">Health</button>
		<button style="right:0; bottom:0;" id="shield" class="ui">Shield</button> -->
		<div id="data">
			<textarea id="csvdata" rows="4" cols="50" >
				paste data here;
			</textarea>
			<button style="right:0; bottom:0;" id="shield">reload</button>
		</div>
		

			
		<script type="module">

			import * as THREE from './lib/three.module.js';

			import Stats from './lib/stats.module.js';
            import { OrbitControls } from './lib/OrbitControls.module.js';
			let container, stats;
			let camera, scene, raycaster, renderer, controls;

			let theta = 0;
			let INTERSECTED;

			const pointer = new THREE.Vector2();
			const radius = 500;
			const frustumSize = 1000;

			const materialargs = {
					color: 0xffffff,
					specular: 0x050505,
					shininess: 50,
					emissive: 0x000000
				};

			var buttons = document.getElementsByTagName("button");
			for (let i = 0; i < buttons.length; i++) {
			buttons[i].addEventListener("click", onButtonClick, false);
			};

			function onButtonClick(event) {
				//alert(event.target.id);
				while(scene.children.length > 0){ 
				scene.remove(scene.children[0]); 
			}
				drawchart();
			}

			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xf0f0f0 );

				//skybox 
				const loadersky = new THREE.CubeTextureLoader();
				const texturesky = loadersky.load([
				'./assets/nebula/posx.png',
				'./assets/nebula/negx.png',
				'./assets/nebula/posy.png',
				'./assets/nebula/negy.png',
				'./assets/nebula/posz.png',
				'./assets/nebula/negz.png',
				]);
				scene.background = texturesky;

				drawchart();

/* 				for ( let i = 0; i < 2000; i ++ ) {

					const object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );

					object.position.x = Math.random() * 800 - 400;
					object.position.y = Math.random() * 800 - 400;
					object.position.z = Math.random() * 800 - 400;

					object.rotation.x = Math.random() * 2 * Math.PI;
					object.rotation.y = Math.random() * 2 * Math.PI;
					object.rotation.z = Math.random() * 2 * Math.PI;

					object.scale.x = Math.random() + 0.5;
					object.scale.y = Math.random() + 0.5;
					object.scale.z = Math.random() + 0.5;

					scene.add( object );

				} */

				raycaster = new THREE.Raycaster();

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				stats = new Stats();
				container.appendChild( stats.dom );


				// init camera
				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.set( 50, 50, 50 );
				camera.lookAt( scene.position );
				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableRotate = true;

				document.addEventListener( 'pointermove', onPointerMove );

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				const aspect = window.innerWidth / window.innerHeight;
/* 
				camera.left = - frustumSize * aspect / 2;
				camera.right = frustumSize * aspect / 2;
				camera.top = frustumSize / 2;
				camera.bottom = - frustumSize / 2;
 */
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onPointerMove( event ) {

				pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

			}

			function drawchart()
			{
				//light
				var light = new THREE.AmbientLight(0xffffff); // soft white light
                scene.add(light);
                var spotLight = new THREE.SpotLight(0xffffff);
                spotLight.position.set(20, 30, 10);
                spotLight.angle = 2.05;
                spotLight.distance = 200;
                scene.add(spotLight);
				
				//const geometry = new THREE.BoxGeometry( 20, 20, 20 );
				//const geometry = new THREE.BoxGeometry( 1, 1, 1 );
				const geometry = new THREE.SphereGeometry( 5, 24, 12 );

				//load file with font

                var rawdata = null;
				var zoomx = 10;
				var zoomy = 10;
				var zoomz = 1000;
				var maxx = -9999;
				var maxy = -9999;
				var maxz = -9999;
				var minx = 9999;
				var miny = 9999;
				var minz = 9999;

				//adding text and points
				const loaderf = new THREE.FontLoader();
				loaderf.load( 'fonts/helvetiker_regular.typeface.json', function ( font ) {

						//readcsv
						
						var loader = new THREE.FileLoader(); 
						//load a text file and output the result to the console
						loader.load(
							// resource URL
							'data2.csv',
							// onLoad callback
							function ( data ) 
							{
								var csvarry = data.split("\n");

								rawdata = new Array(csvarry.length);

								for(var i = 1;i<csvarry.length;i++)
								{
									var temp = csvarry[i].split(",");
									if(temp[0]==null){continue;}
									var x = parseFloat(temp[0]);
									var y = parseFloat(temp[1]);
									var z = parseFloat(temp[2]);

									rawdata[i]=new Array(3); 
									rawdata[i][0]=x;
									rawdata[i][1]=z; //swap y and z
									rawdata[i][2]=y;
									//console.log( rawdata[i] );
                                    var newx = x*zoomx;
									var newy = y*zoomy;
									var newz = z*zoomz;
									//add test
									materialargs.color = new THREE.Color().setHSL(  parseFloat(z)*20, 0.5, 0.5 );

									const material = new THREE.MeshPhongMaterial( materialargs );
									const object = new THREE.Mesh( geometry, material);
									object.position.x = newx;
									object.position.y = newy;
									object.position.z = newz;
									scene.add( object );
                                    
									//label text
									const labelgeo = new THREE.TextGeometry( z, {
										font: font,
										size: 1,
										height: 1 / 2
									} );	
									const textmesh = new THREE.Mesh( labelgeo, material );
									textmesh.position.x = newx;
									textmesh.position.y = newy;
									textmesh.position.z = newz+5;
									scene.add( textmesh ); //slow

									//get max min
									if(maxx<x){maxx=x};
									if(maxy<y){maxy=y};
									if(maxz<z){maxz=z};
									if(minx>x){minx=x};
									if(miny>y){miny=y};
									if(minz>z){minz=z};
								};
								//console.log( maxx );
								//console.log( maxy );
								//console.log( maxz );

								//adding max min boxes
								var newmaxx = maxx * zoomx;
								var newmaxy = maxy * zoomy;
								var newmaxz = maxz * zoomz;
								var newminx = minx * zoomx;
								var newminy = miny * zoomy;
								var newminz = minz * zoomz;
								const material = new THREE.LineBasicMaterial({
									color: 0x0000ff
								});
								var xl = newmaxx-newminx;
								var yl = newmaxy-newminy;
								var zl = newmaxz-newminz;
								//console.log( xl );
								//console.log( yl );
								//console.log( zl );
								const geometryb = new THREE.BoxGeometry( xl, yl, zl );
								const edges = new THREE.EdgesGeometry( geometryb );
								const line = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { color: 0xffffff } ) );
								line.position.x = newminx + xl/2;
								line.position.y = newminy + yl/2;
								line.position.z = newminz + zl/2;
								scene.add( line );

								//adding arrows
								const origin = new THREE.Vector3( newminx, newminy, newminz );
								const colorhex = 0xffff00;
								const lenghfactor = 1.5;//axis arrow length according to xyz length
								const labelfontsize = 10;
								//x y z, swap y and z to give physicial axis feeling
								const arrowx = new THREE.ArrowHelper( new THREE.Vector3( 1, 0, 0 ), origin, xl*lenghfactor, colorhex );
								const arrowy = new THREE.ArrowHelper( new THREE.Vector3( 0, 1, 0 ), origin, yl*lenghfactor, colorhex );
								const arrowz = new THREE.ArrowHelper( new THREE.Vector3( 0, 0, 1 ), origin, zl*lenghfactor, colorhex );
								scene.add( arrowx );
								scene.add( arrowy );
								scene.add( arrowz );
								var label = new THREE.TextGeometry( "X", {
										font: font,
										size: labelfontsize,
										height: labelfontsize / 2
									} );	
								const textmeshx = new THREE.Mesh( label, material );
								textmeshx.position.x = maxx;
								textmeshx.position.y = newminy - 10;
								textmeshx.position.z = newminz;
								label = new THREE.TextGeometry( "Y", {
										font: font,
										size: labelfontsize,
										height: labelfontsize / 2
									} );	
								const textmeshy = new THREE.Mesh( label, material );
								textmeshy.position.x = newminx - 10;
								textmeshy.position.y = maxy;
								textmeshy.position.z = newminz;
								label = new THREE.TextGeometry( "Z", {
										font: font,
										size: labelfontsize,
										height: labelfontsize / 2
									} );	
								const textmeshz = new THREE.Mesh( label, material );
								textmeshz.position.x = newminx - 10;
								textmeshz.position.y = newminy - 10;
								textmeshz.position.z = maxz;
								scene.add( textmeshx ); 
								scene.add( textmeshy ); 
								scene.add( textmeshz ); 

							},
							// onProgress callback
							function ( xhr ) {
									console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
							}
						);

				} );


				
			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}



			function render() {

				theta += 0.1;

			/* 	camera.position.x = radius * Math.sin( THREE.MathUtils.degToRad( theta ) );
				camera.position.y = radius * Math.sin( THREE.MathUtils.degToRad( theta ) );
				camera.position.z = radius * Math.cos( THREE.MathUtils.degToRad( theta ) );
				camera.lookAt( scene.position );

				camera.updateMatrixWorld(); */

				// find intersections

				raycaster.setFromCamera( pointer, camera );

				const intersects = raycaster.intersectObjects( scene.children );

/* 				if ( intersects.length > 0 ) {

					if ( INTERSECTED != intersects[ 0 ].object ) {

						if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

						INTERSECTED = intersects[ 0 ].object;
						INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
						INTERSECTED.material.emissive.setHex( 0xff0000 );

					}

				} else {

					if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

					INTERSECTED = null;

				} */

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>